---
title: HashMap源码解析
tags:
  - Collection
categories:
  - Java
date: 2016-08-02 17:35:00
---


> 一坑未平，一坑又起，今天我们来看一下HashMap
> HashMap继承自AbstractMap，实现Map接口，是一个标准的Map实现

<!-- ![HashMap_DiaGram](http://oaxbg6rvg.bkt.clouddn.com/HashMap_DiaGram.png) -->
<!-- more -->


*初始化*
==============

*HashMap*
--------------

一个参数为初始大小值， 一个为填充因子，可以发现，在构造函数里面除了基本的赋值外，并没有做数据初始化的操作，而那个init()则是个幌子= =，正宗的啥也没干啊

``` Java
/**
 * Constructs an empty <tt>HashMap</tt> with the specified initial
 * capacity and load factor.
 *
 * @param  initialCapacity 初始大小
 * @param  loadFactor      填充因子
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);

    this.loadFactor = loadFactor;
    threshold = initialCapacity;
    init(); // 是叫init，可是啥也没干啊，直到小弟LinkedHashMap做了点事儿
}
```

*init*
--------------
初始化方法`init`
主要工作是卖萌
``` Java
/**
 * Initialization hook for subclasses. This method is called
 * in all constructors and pseudo-constructors (clone, readObject)
 * after HashMap has been initialized but before any entries have
 * been inserted.  (In the absence of this method, readObject would
 * require explicit knowledge of subclasses.)
 */
void init() {
  // 你看，我真的啥也没干
}
```

*inflateTable*
--------------
初始化table，table是真正存储数据的数组
`inflateTable`方法，给Table充气嘛，也很是形象

``` Java
/**
 * Inflates the table.
 */
private void inflateTable(int toSize) {
    // Find a power of 2 >= toSize
    int capacity = roundUpToPowerOf2(toSize);
    //这里很精妙的设置了capacity

    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
    // 设置哈希种子 We defer initialization until we really need it.
}
```

在`roundUpTOPowerOf2`方法里面返回的是2的N次方，假设为X，N取使得X大于toSize的集合中的最小值，例如
``` Java
roundUpToPowerOf2(31) = 32
roundUpToPowerOf2(60) = 64
```

*添加元素*
==============

*put*
--------------

重头戏`put`方法，添加元素
如上图所说，*We defer initialization until we really need it.*, 那么很容易联想到，inflateTable函数其实是在put方法里面会被调用，因为这时候才really need it嘛。

``` Java
/**
 * Associates the specified value with the specified key in this map.
 * If the map previously contained a mapping for the key, the old
 * value is replaced.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with <tt>key</tt>, or
 *         <tt>null</tt> if there was no mapping for <tt>key</tt>.
 *         (A <tt>null</tt> return can also indicate that the map
 *         previously associated <tt>null</tt> with <tt>key</tt>.)
 */
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold); //如果是空Map的话，就做初始化操作
    }
    if (key == null)
        return putForNullKey(value); // 这里对null值做了单独的处理
    int hash = hash(key);
    int i = indexFor(hash, table.length); // 这个indexFor巧妙利用了table的Length
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        // 如果hash值一样(键冲突)，并key是真的一样的话
        // 则用新的value覆盖老value，返回老value
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 如果没有出现key完全相同的情况(例如hash值不同，或者只是hash冲突了)
    // 添加新的Entry，这个addEntry的部分需要好好看看
    addEntry(hash, key, value, i);
    return null;
}

```

*put-indexFor*
--------------
由给定的hash值，返回对应的哈希桶下标
直接使用`length-1`和`hash`值进行与操作， 因为`length`是2的次方，所以`length -1`所有位上都是1，直接与操作可以迅速获得对应的Index值
``` Java
/**
 * Returns index for hash code h.
 */
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}

```



*put-addEntry*
--------------
给将数据添加到table中，
如果有必要，new一个新的table :)
``` Java
/**
* Adds a new entry with the specified key, value and hash code to
* the specified bucket.  It is the responsibility of this
* method to resize the table if appropriate.
*
* Subclass overrides this to alter the behavior of put method.
*/
void addEntry(int hash, K key, V value, int bucketIndex) {
 // 如果当前Map的size已经大于阈值，并且当前这个哈系桶也已经被实例化过的话
 // 则需要进行长度填充，新长度为原长度的2倍
   if ((size >= threshold) && (null != table[bucketIndex])) {
       resize(2 * table.length); // resize的开销比较大，我们一会看一下
       hash = (null != key) ? hash(key) : 0;
       bucketIndex = indexFor(hash, table.length);// 获得哈希桶的下标
   }
     createEntry(hash, key, value, bucketIndex);
}
```


*put-addEntry-resize*
--------
resize，对table进行扩容
需要完成几个步骤
1. 开辟新数组
2. 将oldTable中的值全部映射newTable中
3. 如果有必要的话，重新生成hashSeed(这块我没看懂，欢迎大神指教)

``` Java
/**
 * Rehashes the contents of this map into a new array with a
 * larger capacity.  This method is called automatically when the
 * number of keys in this map reaches its threshold.
 *
 * If current capacity is MAXIMUM_CAPACITY, this method does not
 * resize the map, but sets threshold to Integer.MAX_VALUE.
 * This has the effect of preventing future calls.
 *
 * @param newCapacity the new capacity, MUST be a power of two;
 *        must be greater than current capacity unless current
 *        capacity is MAXIMUM_CAPACITY (in which case value
 *        is irrelevant).
 */
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable, initHashSeedAsNeeded(newCapacity)); // 转移元素
    table = newTable;  //将table的引用替换
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    // 更新 threshold， MAXIMUM_CAPACITY的值是 2^30
}
```

*put-addEntry-resize-transfer*
--------
`transfer`倒是意外的简单，由老table添加到新table，循环遍历，将值插入即可

``` Java
/**
 * Transfers all entries from current table to newTable.
 */
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

*put-addEntry-resize-initHashSeedAsNeeded*
--------
初始化hashSeed
还记得那句 *We defer initialization until we really need it.* 嘛？ 出处来自这里了，switching的取值不是特别明白

``` Java
/**
 * Initialize the hashing mask value. We defer initialization until we
 * really need it.
 */
final boolean initHashSeedAsNeeded(int capacity) {
    boolean currentAltHashing = hashSeed != 0;
    boolean useAltHashing = sun.misc.VM.isBooted() &&
            (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);
    boolean switching = currentAltHashing ^ useAltHashing;
    if (switching) {
        hashSeed = useAltHashing
            ? sun.misc.Hashing.randomHashSeed(this)
            : 0;
    }
    return switching;
}
```

*put-addEntry-createEntry*
--------
最底层的添加元素的方法，
是不是简单得亮瞎了眼=。= 唯一能干点活的也就只有Entry的构造函数了，一起看一下

``` Java
/**
     * Like addEntry except that this version is used when creating entries
     * as part of Map construction or "pseudo-construction" (cloning,
     * deserialization).  This version needn't worry about resizing the table.
     *
     * Subclass overrides this to alter the behavior of HashMap(Map),
     * clone, and readObject.
     */
    void createEntry(int hash, K key, V value, int bucketIndex) {
        Entry<K,V> e = table[bucketIndex];
        // 获得当前哈希桶的实例
        table[bucketIndex] = new Entry<>(hash, key, value, e);
        // 直接new一个Entry，然后替换掉原有的哈系桶，使用链表结构保存原来旧值的实例
        // 直接使用哈希桶找到的地一个值，总是最近插入到这个哈希桶的值(有一点时间局部性的意味？)
        // 具体看Entry的分析
        size++; //新添加了一个元素，size加1
    }
```

*HashMap.Entry*
-------------

Entry是HashMap内部用来存储具体数据的内部类，所有的数据存储在一个Entry<K,V>类型的数组中，看一下Entry的定义

``` Java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;

    /**
     * Creates new entry.
     */
    Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        // 这里将原来在这个位置的value保存在了next里面，
        // 也就是newEntry总是添加在这个哈希桶的链表首部
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    // 为节省篇幅，此处省去了一些关系不大的方法.....
}

```


*遍历元素*
==============

遍历HashMap最快的方法是？ 没错，是EntrySet()

*祭出神图*
------
先祭出这张神图，有个印象我们再往下看

``` Java
HashMap
    |- table <------------------------------------\
    \+ entrySet()                                 |iterates
        |              HashMap.HashIterator<T>    |
        |returns                ^       \- nextEntry()
        V                       -                 ^
HashMap.EntrySet                |                 |
    \- iterator()               |extends          |
            |                   |                 |
            |  instantiats      |                 |calls
            \----------> HashMap.EntryIterator    |
                                        \- next() /
```


*再看代码*
------

看一下代码，entrySet()的结构非常简单，有一点需要注意，下面的函数 *不是构造函数*
``` Java
/**
 * Returns a {@link Set} view of the mappings contained in this map.
 * The set is backed by the map, so changes to the map are
 * reflected in the set, and vice-versa.  If the map is modified
 * while an iteration over the set is in progress (except through
 * the iterator's own <tt>remove</tt> operation, or through the
 * <tt>setValue</tt> operation on a map entry returned by the
 * iterator) the results of the iteration are undefined.  The set
 * supports element removal, which removes the corresponding
 * mapping from the map, via the <tt>Iterator.remove</tt>,
 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
 * <tt>clear</tt> operations.  It does not support the
 * <tt>add</tt> or <tt>addAll</tt> operations.
 *
 * @return a set view of the mappings contained in this map
 */
public Set<Map.Entry<K,V>> entrySet() {
    return entrySet0();
}

private Set<Map.Entry<K,V>> entrySet0() {
    Set<Map.Entry<K,V>> es = entrySet;
    return es != null ? es : (entrySet = new EntrySet());
}
```

看上去entrySet保存了一份数据，然后返回的时候直接返回了数据集合，然而这里有一个大坑，实际上EntrySet远远比这牛逼太多了
EntrySet是使用iterator来进行遍历，而iterator所调用的内存空间恰好是HashMap保存的table！！！

*entrySet其实是table的另外一种展现形式，table改变，entrySet也改变，反之亦然*
Aka
*Returns a  view of the mappings contained in this map.
The set is backed by the map, so changes to the map are
reflected in the set, and vice-versa.*
看不懂没关系，我们慢慢分析 (为了连惯性，以下使用一张长代码块进行展示)


``` Java
/**
 * EntrySet 类定义
 */
private final class EntrySet extends AbstractSet<Map.Entry<K,V>> {
    public Iterator<Map.Entry<K,V>> iterator() {
        return newEntryIterator();
        // 这里返回 newEntryInteator，这里是神来之笔
    }
    // 为节省篇幅，省略其他部分方法
}


/**
 * newEntryIterator 是HashMap下的方法
 * 做的事情和方法名字一样，new 一个 EntryIterator 对象
 */
Iterator<Map.Entry<K,V>> newEntryIterator()   {
    return new EntryIterator();
}


/**
 * EntryIterator 是 HashIterator 的子类，
 * 仅仅重写了next()方法，
 * 而next方法中调用的nextEntry()，其实也属于 HashIterator
 */
private final class EntryIterator extends HashIterator<Map.Entry<K,V>> {
    public Map.Entry<K,V> next() {
        return nextEntry(); // 是不是有点眼熟?
    }
}


/**
 * HashIterator 是 Iterator 的子类
 * 重点看 构造函数 和 nextEntry() 方法
 */
private abstract class HashIterator<E> implements Iterator<E> {
    Entry<K,V> next;        // next entry to return
    int expectedModCount;   // For fast-fail
    int index;              // current slot
    Entry<K,V> current;     // current entry

    HashIterator() {
        expectedModCount = modCount; // 这里对 expectedModCount 赋值，遍历时做校验
        if (size > 0) { // advance to first entry
            /***************************************/
            Entry[] t = table;
            /***************************************/
            // 看这里! 看这里! 看这里!
            // 看这里! 看这里! 看这里!
            // 看这里! 看这里! 看这里!
            // t 是 table， 而 table 就是 HashTable 用来存放数据的呀!!!!
            // 也就是说底层实际上是共用的一套数据！


            // 这一行也很有意思， advance to first entry
            // 移到地一个entry，这里所指向的 entry 和 put 进 map 的顺序没有关系
            // index 最终的值为 哈希桶中最小的非空桶的下标
            while (index < t.length && (next = t[index++]) == null)
                ;
        }
    }

    public final boolean hasNext() {
        return next != null;
    }

    /**
     * nextEntry()
     * EntryIterator 的 next() 最终调用的方法，也就是迭代器的返回值
     *
     *
     */
    final Entry<K,V> nextEntry() {
        // 这里比较了 modCount 和 expectedModCount的取值，如果不同则抛出异常
        // expectedModCount 在 HashIterator 的构造器里赋值， 初始值就是 modCount
        // 而 modCount 在 HashMap 进行元素改变时候会进行 ++ 操作
        // 当然这并没什么鸟用，因为完全可以先校验过再同时线程进入竞争区 逃(
        //

        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Entry<K,V> e = next;
        if (e == null)
            throw new NoSuchElementException();

        // 先看当前哈希桶中是否已经到链表末尾
        // 如果是的话就找下一个哈希桶，直到 table 中最后一个哈希桶中的链表的最后一个元素
        if ((next = e.next) == null) {
            Entry[] t = table;
            while (index < t.length && (next = t[index++]) == null)
                ;
        }
        current = e;
        return e;
    }
    // 为了节省篇幅，减去了一些不必要的代码
}

```



*其他*
==============

最重要的精华前面已经讲过，还剩下一些其他零散的点，

*get*
------

`get`方法，本质上调用的`getEntry`方法，比较简单，不具体介绍了
``` Java
/**
 * Returns the value to which the specified key is mapped,
 * or {@code null} if this map contains no mapping for the key.
 *
 * <p>More formally, if this map contains a mapping from a key
 * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
 * key.equals(k))}, then this method returns {@code v}; otherwise
 * it returns {@code null}.  (There can be at most one such mapping.)
 *
 * <p>A return value of {@code null} does not <i>necessarily</i>
 * indicate that the map contains no mapping for the key; it's also
 * possible that the map explicitly maps the key to {@code null}.
 * The {@link #containsKey containsKey} operation may be used to
 * distinguish these two cases.
 *
 * @see #put(Object, Object)
 */
public V get(Object key) {
    if (key == null)
        return getForNullKey();
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

/**
 * Returns the entry associated with the specified key in the
 * HashMap.  Returns null if the HashMap contains no mapping
 * for the key.
 */
final Entry<K,V> getEntry(Object key) {
    if (size == 0) {
        return null;
    }

    int hash = (key == null) ? 0 : hash(key);
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            return e;
    }
    return null;
}
```



*clone*
------
克隆方法，注释写得很清楚了`Returns a shallow copy`，比较危险的方法，不推荐使用

``` Java
/**
 * Returns a shallow copy of this <tt>HashMap</tt> instance: the keys and
 * values themselves are not cloned.
 *
 * @return a shallow copy of this map
 */
public Object clone() {
    HashMap<K,V> result = null;
    try {
        result = (HashMap<K,V>)super.clone();
    } catch (CloneNotSupportedException e) {
        // assert false;
    }
    if (result.table != EMPTY_TABLE) {
        result.inflateTable(Math.min(
            (int) Math.min(
                size * Math.min(1 / loadFactor, 4.0f),
                // we have limits...
                HashMap.MAXIMUM_CAPACITY),
           table.length));
    }
    result.entrySet = null;
    result.modCount = 0;
    result.size = 0;
    result.init();
    result.putAllForCreate(this);

    return result;
}
```


*Another HashMap Constructor*
------
注，这里是使用了putAllForCreate，使用了shallow copy，不推荐这样做

``` Java
/**
  * Constructs a new <tt>HashMap</tt> with the same mappings as the
  * specified <tt>Map</tt>.  The <tt>HashMap</tt> is created with
  * default load factor (0.75) and an initial capacity sufficient to
  * hold the mappings in the specified <tt>Map</tt>.
  *
  * @param   m the map whose mappings are to be placed in this map
  * @throws  NullPointerException if the specified map is null
  */
public HashMap(Map<? extends K, ? extends V> m) {
    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
    inflateTable(threshold);

    putAllForCreate(m);
}
```

*diamond types are not supported at this language level*
---------------------

在调试时，把HashMap源码全部复制出来，结果编译不过，告知 `diamond types are not supported at this language level`

``` Java
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e); // 就是这一行
    //                           ↑↑↑↑
    //                           here
    //
    size++;
}
```
经过搜索，发现其实是项目所使用的是language level 6，如下图所示进行修改即可
![languageLevel](http://oaxbg6rvg.bkt.clouddn.com/LanguageLevel.png)


*mystical transient?*
---------------------
在复制源码的时候，发现在全选的情况下，一下两行没有被复制过来，难道这和`transient`有关系？？？
但是同样被`transient`修饰的`entrySet`却被复制了过来，明明都是`Ctrl-C Ctrl-V`为啥有区别嘞 =。=

``` Java
transient volatile Set<K>        keySet = null;  // 我没有被复制哦
transient volatile Collection<V> values = null;  // 我没有被复制哦

private transient Set<Map.Entry<K,V>> entrySet = null; // 我被复制了哦
```




*小结*
======

HashMap是一个很强大的集合类，小结一下:
1. 其中使用Hash函数进行较快的检索，在`hash`冲突时使用链表进行数据的存储
2. 当内部空间不足时，会自动进行扩容，扩容长度为原来的2倍，并且会将旧的数据全部映射到新数据上，当HashMap长度较大时，再进行扩展开销会比较大
3. 遍历HashMap时，最好使用`EntrySet()`进行遍历，使用的时候注意方法
The set supports element removal, which removes the corresponding mapping from the map,
***via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations.***  
***It does not support the add or addAll operations.***
